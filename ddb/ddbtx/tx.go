// Package ddbtx provides an expressive API for building DynamoDB transactions
package ddbtx

import (
	"context"
	"errors"
	"fmt"

	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/expression"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// @TODO add a "table resolver" argument to the transaction, or maybe to the package. It type asserts a
// dynamodb message and should return a table name. It should be easily configured as a dependency through
// env variables.

// @TODO add (cofingurable) logic that turns single operation transactions into their simple form. So if
// a write transaction only has a PutItem, just turn it into a put item

// Item interface is implemented by Go code generated by our
type Item interface {
	// MarshalDynamoItem should marshal every attribute of the item, including keys.
	MarshalDynamoItem() (m map[string]types.AttributeValue, err error)
	// DynamoKeyNames return the attribute names of the pk as the first element, and the optional sort
	// key as the second element. If the item has no keys defined it should return an empty slice.
	DynamoKeyNames() []string
}

// Write starts a write transaction
func Write() *WriteTx {
	return &WriteTx{}
}

// WriteTx allows for building a write transaction
type WriteTx struct {
	its []types.TransactWriteItem
	err error
}

// errorf adds a formatted error
func (wtx WriteTx) errorf(format string, v ...any) WriteTx {
	// @TODO automatically log operation/position in transaction
	wtx.err = errors.Join(wtx.err, fmt.Errorf(format, v...))
	return wtx
}

// Commit the transaction
func (wtx WriteTx) Commit(ctx context.Context) error {
	if wtx.err != nil {
		return wtx.err // failed to build transaction in the first place
	}

	// @TODO simplify single item transactions
	// @TODO call actual client

	return nil
}

func withShouldNotExist(exprb expression.Builder, it Item) expression.Builder {
	return withPkExistence(exprb, it, true)
}

func withShouldExist(exprb expression.Builder, it Item) expression.Builder {
	return withPkExistence(exprb, it, false)
}

func withPkExistence(exprb expression.Builder, it Item, notExists bool) expression.Builder {
	keys := it.DynamoKeyNames()
	if len(keys) < 1 {
		// code generation and interface assertion should ensure this should never happen with
		// our generated code. Could happen if user decides to mock or imlement their own mehtods.
		panic("no partition key name returned ")
	}
	cond := expression.Name(keys[0]).AttributeExists()
	if notExists {
		cond = expression.Name(keys[0]).AttributeNotExists()
	}

	return exprb.WithCondition(cond)
}
